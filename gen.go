// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates rivers.go. It can be invoked by running
// go generate
package main

import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/robtuley/rainchasers/internal/river"
	"gopkg.in/yaml.v2"
)

type YamlCalibration struct {
	URL         string   `yaml:"data_url"`
	Description string   `yaml:"desc"`
	Scrape      *float32 `yaml:"scrape,omitempty"`
	Low         *float32 `yaml:"low,omitempty"`
	Medium      *float32 `yaml:"medium,omitempty"`
	High        *float32 `yaml:"high,omitempty"`
	Huge        *float32 `yaml:"huge,omitempty"`
	TooHigh     *float32 `yaml:"toohigh,omitempty"`
}

type YamlMeasures struct {
	Measures []YamlCalibration `yaml:"measures"`
}

func main() {
	files, err := filepath.Glob("./rivers/*.yaml")
	die(err)

	var sections []river.Section
	calibrations := make(map[string][]river.Calibration)

nextFile:
	for _, fn := range files {
		y, err := ioutil.ReadFile(fn)
		die(err)

		// parse a section from yaml
		var s river.Section
		err = yaml.Unmarshal(y, &s)
		die(err)
		s.Slug = strings.TrimSuffix(filepath.Base(fn), ".yaml")
		sections = append(sections, s)

		// parse a calibration from yaml
		var m YamlMeasures
		err = yaml.Unmarshal(y, &m)
		die(err)
		if len(m.Measures) == 0 {
			continue nextFile
		}
		var all []river.Calibration
		for _, yc := range m.Measures {
			all = append(all, yamlCalibrationToRiverCalibration(yc))
		}
		calibrations[s.UUID] = all
	}

	f, err := os.Create("rivers.go")
	die(err)
	defer f.Close()

	packageTemplate.Execute(f, struct {
		Timestamp    time.Time
		Sections     []river.Section
		Calibrations map[string][]river.Calibration
	}{
		Timestamp:    time.Now(),
		Sections:     sections,
		Calibrations: calibrations,
	})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from /rivers content directory
package rainchasers

import "github.com/robtuley/rainchasers/internal/river"

// Calibrations define those sections calibrated in uuid keyed map
var Calibrations = map[string][]river.Calibration{
{{- range $key, $value := .Calibrations }}
	{{ printf "%#v" $key }}: {{ printf "%#v" $value }},
{{- end }}
}

// Sections are the river sectionn definitions
var Sections = []river.Section{
{{- range .Sections }}
	{{ printf "%#v" . }},
{{- end }}
}
`))

func yamlCalibrationToRiverCalibration(yc YamlCalibration) river.Calibration {
	c := river.Calibration{
		URL:         yc.URL,
		Description: yc.Description,
		Minimum:     make(map[string]float32),
	}
	if yc.Scrape != nil {
		c.Minimum[river.Scrape.String()] = *yc.Scrape
	}
	if yc.Low != nil {
		c.Minimum[river.Low.String()] = *yc.Low
	}
	if yc.Medium != nil {
		c.Minimum[river.Medium.String()] = *yc.Medium
	}
	if yc.High != nil {
		c.Minimum[river.High.String()] = *yc.High
	}
	if yc.Huge != nil {
		c.Minimum[river.Huge.String()] = *yc.Huge
	}
	if yc.TooHigh != nil {
		c.Minimum[river.TooHigh.String()] = *yc.TooHigh
	}
	return c
}
